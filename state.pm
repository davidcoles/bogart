#!/usr/bin/perl
package state;
use strict;
use Switch;
use JSON;
use Corosync::CPG qw/:constants/;
use base qw(Corosync::CPG);
use Digest::MD5 qw(md5_hex);
our $SELF;

sub confchg       {} # to be notified about leave/join events
sub process_event {} # to process events generated by PDUs
sub initialise    {} # called when application joins the group
sub serialise     {} # serialse the application state to be copied to a replica
sub deserialise   {} # deserialise the application state from a replica
sub dump          { {} }

sub reset     { $_[0]->{_STATE} = 'START'; $_[0]->initialise; warn "RESET\n" }
sub nodeid    { $_[0]->local_get .":$$" }
sub md5       { $_[0]->{_md5} }
sub running   { $_[0]->{_STATE} eq 'RUNNING' ? 1 : 0 }
sub error     { $_[0]->{_STATE} eq 'ERROR)'  ? 1 : 0 }
sub finished  { $_[0]->{_STATE} =~ /^(FINISHED|ERROR)$/ ? 1 : 0 }
sub finish    { $_[0]->fsm('FIN_RECV') }
sub step      { $_[0]->SUPER::dispatch(CS_DISPATCH_ALL) }
sub sendpdu   { $_[0]->sendmsg('PDU', undef, $_[1]) }
sub sendmsg   {
    my($self, $type, $unto, $body) = @_;
    my $msg = to_json({ type => $type, unto => $unto, body => $body });
    warn sprintf ">%s %s\n", $type, substr($msg, 0, 75) if $ENV{DEBUG} > 1;
    $self->mcast_joined(CPG_TYPE_AGREED, $msg);
}

sub members {
    my($self, @del) = @_;
    foreach(@del) { delete $self->{_wai}->{$_} };
    scalar keys %{$self->{_wai}};
}

sub new {
    my($pkg, $group) = @_;
    $group = 'default' unless defined $group;
    $SELF = my $self = $pkg->SUPER::new(callbacks => {
	deliver => \&deliver_callback, confchg => \&confchg_callback });
    $self->join($group);

    # seems it's possible to bind to 127.0.0.1
    if($self->nodeid =~ /^16777343:/ && ! -t \*STDIN && !defined $ENV{DEBUG}) {
	warn "16777343 - bound to localhost - set DEBUG env var to ignore\n";
	sleep 5;
	exit;
    }

    $self->{_que} = [];
    $self->{_wai} = {};
    $self;
}

sub deliver_callback {
    my($g, $n, $p, $m, $self) = @_; $self = $SELF unless defined $self;
    my($type,$unto,$body) = @{from_json($m)}{qw(type unto body)};
    
    return if defined $unto and $unto ne $self->nodeid; # not to me ..,
    
    my $req_event = "$n:$p" eq $self->nodeid ? 'REQ_SELF' : 'REQ_OTHR';	
    $req_event = 'REQ_WAIT' if exists $self->{_wai}{"$n:$p"};

    warn sprintf "<%s %s\n", $type, substr($m, 0, 75) if $ENV{DEBUG} > 1;

    switch($type) {
	case 'REQ' { $self->fsm($req_event, "$n:$p") }
	case 'NAK' { $self->fsm('NAK_RECV', "$n:$p") }
	case 'INI' { $self->fsm('INI_RECV', "$n:$p", @$body) }
	case 'ACK' { $self->fsm('ACK_RECV', "$n:$p", @$body) }
	case 'PDU' { $self->fsm('PDU_RECV', "$n:$p", $body, $m) }
	case 'ENQ' { warn sprintf "ENQ %s\n", $self->md5 }
	case 'DMP' { warn sprintf "DMP %s\n", $self->dump }
	else { die sprintf ">> %s %s\n", $type, $self->serialise }
    }
}

sub confchg_callback { # called when a node joins or leaves the group
    my($group, $members, $leaving, $joining, $self) = @_;
    $self = $SELF unless defined $self;
    my @members = sort map { join(':', $_->{nodeid}, $_->{pid}) } @$members;
    my @leaving = sort map { join(':', $_->{nodeid}, $_->{pid}) } @$leaving;
    my @joining = sort map { join(':', $_->{nodeid}, $_->{pid}) } @$joining; 
    my $nodeid = $self->nodeid;

    %{$self->{_mem}} = map { $_ => 1 } grep !/^$nodeid$/, @members;
    
    foreach(@leaving) {$self->fsm($_ eq $nodeid ? 'SLF_LEAV' : 'OTH_LEAV', $_)}
    foreach(@joining) {$self->fsm($_ eq $nodeid ? 'SLF_JOIN' : 'OTH_JOIN', $_)}
    $self->confchg($group, [@members], [@leaving], [@joining]);
}


#############################################################################
sub SEND_ACK { $_[0]->sendmsg('ACK',$_[1],[$_[0]->md5,$_[0]->serialise]); () }
sub SEND_NAK { $_[0]->sendmsg('NAK',$_[1]); () }
sub SEND_REQ { $_[0]->sendmsg('REQ'); () }
sub RECV_NAK { $_[0]->members($_[1]) ? () : (['NUL_LIST']) }
sub PUSH_PDU { push(@{shift->{_que}}, [@_]); () }

sub SEND_INI {
    my($self) = @_;
    $self->initialise;
    $self->{_que} = [];
    $self->sendmsg('INI', undef, [ md5_hex($self->nodeid),$self->serialise ]);
    return ();
}

sub RECV_ACK {
    my($self, $from, $md5, $shd) = @_;  warn "ACK<$md5 $from\n" if $ENV{DEBUG};
    $self->{_wai} = {};
    $self->{_md5} = $md5;
    $self->deserialise($shd);
    map { $self->PROC_PDU(@$_) } @{$self->{_que}};
    $self->{_que} = [];
    return ();
}

sub PROC_PDU {
    my($self, $from, $body, $m) = @_;
    $self->{_md5} = md5_hex($self->md5.$m);
    $self->process_event($body, $from);
    return ();
}

sub STRT_QUE {
    my($self) = @_;
    $self->{_que} = [];
    $self->{_wai} = $self->{_mem};
    return $self->members ? () : (['NUL_LIST']);
}

sub _fsm {
  my($self, $s, $e, @a) = @_;
  switch($s) {
    case "ERROR" {
      switch($e) {
      }
      return ('ERROR');
    }
    case "FINISHED" {
      switch($e) {
      }
      return ('FINISHED');
    }
    case "INI_SENT" {
      switch($e) {
        case "ACK_RECV" { return ("ERROR") }
        case "INI_RECV" { return ("RUNNING", $self->RECV_ACK(@a)) }
        case "SLF_LEAV" { return ("FINISHED") }
      }
      return ('INI_SENT');
    }
    case "REQ_RCVD" {
      switch($e) {
        case "ACK_RECV" { return ("RUNNING", $self->RECV_ACK(@a)) }
        case "INI_RECV" { return ("RUNNING", $self->RECV_ACK(@a)) }
        case "NAK_RECV" { return ("REQ_RCVD", $self->RECV_NAK(@a)) }
        case "NUL_LIST" { return ("INI_SENT", $self->SEND_INI(@a)) }
        case "OTH_JOIN" { return ("REQ_RCVD") }
        case "OTH_LEAV" { return ("REQ_RCVD", $self->RECV_NAK(@a)) }
        case "PDU_RECV" { return ("REQ_RCVD", $self->PUSH_PDU(@a)) }
        case "REQ_OTHR" { return ("REQ_RCVD") }
        case "REQ_WAIT" { return ("REQ_RCVD", $self->SEND_NAK(@a)) }
        case "SLF_LEAV" { return ("FINISHED") }
      }
      return ('ERROR');
    }
    case "REQ_SENT" {
      switch($e) {
        case "REQ_OTHR" { return ("REQ_SENT", $self->SEND_NAK(@a)) }
        case "REQ_SELF" { return ("REQ_RCVD", $self->STRT_QUE(@a)) }
        case "SLF_LEAV" { return ("FINISHED") }
      }
      return ('REQ_SENT');
    }
    case "RUNNING" {
      switch($e) {
        case "FIN_RECV" { return ("FINISHED") }
        case "PDU_RECV" { return ("RUNNING", $self->PROC_PDU(@a)) }
        case "REQ_OTHR" { return ("RUNNING", $self->SEND_ACK(@a)) }
        case "SLF_LEAV" { return ("FINISHED") }
      }
      return ('RUNNING');
    }
    case "START" {
      switch($e) {
        case "SLF_JOIN" { return ("REQ_SENT", $self->SEND_REQ(@a)) }
      }
      return ('START');
    }
  }
}
sub fsm {
    my($self, $e, @a) = @_;
    $self->{_STATE} = 'START' unless defined $self->{_STATE};
    my $s = $self->{_STATE};
    warn "<$s, $e [$a[0]]\n" if $ENV{DEBUG}>2;
    my($n, @e) = $self->_fsm($s, $e, @a);
    warn "=$n\n" if $ENV{DEBUG}>2;
    $self->{_STATE} = $n;
    foreach(@e) { $self->fsm(@$_) }
}
1;


